Application Vulnerability Assessment (AVA) 
Vulnerability Catalog and Template




Maintained by Information Security & Risk (ISR)
Version 3.7
Last Revision: 19 April 2017 
Table of Contents
INTRODUCTION	5
Purpose	5
Target Audience	5
Scope	5
Assumptions	5
VULNERABILITIES	6
A1 ? INJECTION	6
SQL Injection	6
Blind SQL Injection	6
LDAP Injection	7
XML Injection	7
Link Injection	8
Command Injection	8
Input Validation Misconfiguration	9
A2 ? BROKEN AUTHENTICATION AND SESSION MANAGEMENT	10
Authentication Bypass	10
Logout Functionality Missing	10
Session Expiration Missing	11
Session Invalidation Misconfiguration	11
Account Lockout Functionality Misconfiguration	12
Default Credentials	12
Hardcoded Password	12
Secure Flag Not Set on Session Cookies	13
Session Hijacking	14
A3 ? CROSS-SITE SCRIPTING (XSS)	15
Cross-Site Scripting (XSS) - Stored	15
Cross-Site Scripting (XSS) - Reflected	15
Cross-Site Scripting (XSS) - DOM-Based	16
A4 ? INSECURE DIRECT OBJECT REFERENCES	17
Backup [File|Firmware] Available without Authentication	17
Update [File|Firmware] Available without Authentication	17
A5 ? SECURITY MISCONFIGURATION	18
Application Fails to Use HTTPS	18
SSL/TLS Certificate Misconfiguration	18
Browser Exploit Against SSL/TLS (a.k.a. BEAST)	18
HTTP Method Tampering	19
Arbitrary HTTP Methods Allowed	19
Cacheable SSL/TLS Pages	20
Cross Frame Scripting Defense Header Misconfiguration	20
Content-Security-Policy (CSP) Header Misconfiguration	21
X-Content-Type-Options Header Misconfiguration	21
X-XSS-Protection Header Misconfiguration	22
HttpOnly Flag Not Set on Cookies	22
HTTP Strict Transport Security (HSTS) Header Misconfiguration	23
Email Spoofing	23
Directory Traversal	24
Application Denial of Service (DoS)	24
A6 ? SENSITIVE DATA EXPOSURE	25
Sensitive Data Stored Unencrypted	25
Hardcoded Encryption Keys	25
Information Disclosure	25
Application Design Document Issues	26
Username/Account Enumeration	26
Sensitive Input Fields Not Masked	27
A7 ? MISSING FUNCTION LEVEL ACCESS CONTROL	28
Arbitrary File Read Access	28
Arbitrary File Write Access	28
Insufficient Physical Access Controls	28
Improper Access Controls	29
Privilege Escalation	29
Forced Browsing	29
Business Logic Misconfiguration	30
Default Pages Accessible	30
A8 ? CROSS-SITE REQUEST FORGERY	32
Cross-Site Request Forgery (CSRF)	32
Anti-CSRF Token Missing	32
A9 ? USING COMPONENTS WITH KNOWN VULNERABILITIES	34
Account Backdoor	34
Out of Date Software	34
Using a Module/Function with a Known Vulnerability	35
A10 ? UNVALIDATED REDIRECTS AND FORWARDS	36
Unvalidated Redirects and Forwards	36
Subresource Integrity (SRI) Missing	36
Appendix	38
Version History	38

 
INTRODUCTION
Purpose
The purpose of this document is to inventory and catalog all the vulnerabilities historically found in previous application vulnerability assessments (AVAs).  This information will be used for two primary purposes.  First, it will be used for the categories in Archer GRC and by using the same names for any given vulnerability ISR will have better analytics and insight into what types of vulnerabilities we are seeing.  Second, this will make AVA reporting easier and quicker so that ISR can get results to the business partners faster and more consistently.
Target Audience
This document is specifically for the AVA team members but additional target audience members include other members of ISR, BISOs, the XBU meeting representatives, and project managers that need to coordinate Agile sprints or other developer resources to remediate found vulnerabilities in applications.
Scope
All vulnerabilities found in any applications previously tested by ISR will be included in this document.  Going forward, vulnerabilities that are not currently included in will be added.
This document is broken up into sections based on the OWASP Top 10 2013 and many descriptions or explanations have been taken from the following site verbatim: https://www.owasp.org/index.php/Top_10_2013-Top_10.  This link may be helpful in finding additional information on vulnerabilities not listed in this catalog: https://www.owasp.org/index.php/Category:Vulnerability
Assumptions
The use of this document as a report template is for the use of AVA reports and not necessarily exhaustive of all details.  While this document serves as a template, each application is different and will require modifications to the descriptions, risks, or recommendations based on the specifics of the application that is being tested.  Any highlighted paragraph or section MUST be updated specific to the application and finding. 
VULNERABILITIES
A1 ? INJECTION
SQL Injection
Description
SQL injection occurs when data, such as user input data from web forms, is passed from the application to the back end SQL database and executed as code.  Typically a form is looking to receive information to build a SQL query, but with SQL injection an attacker is able to enter characters or strings that are actually valid commands within the Structured Query Language.  

Risk
If untrusted user data that is accepted and not validated or sanitized, then depending on the query that is built, the database may execute the inputted data as query code, return unauthorized data from database, modify the database in some way, or escape the database entirely and store and execute code on the underlying server.

Recommendation and Resources
Whitelisting ? the defining of the universe of approved or acceptable characters only ? is the recommended way to avoid SQL injection.  Some applications require special characters and therefore whitelisting is not feasible.  In this case the preferred option is to use the built-in secure code libraries in the programming language?s framework (see the Software Security Standards link below).  

https://docs.company.com/display/SS/Software+Security+Standards%2C+Guidelines+and+Best+Practices
https://www.owasp.org/index.php/SQL_Injection
https://www.owasp.org/index.php/SQL_Injection_Prevention_Cheat_Sheet


Blind SQL Injection
Description
SQL injection occurs when data, such as user input data from web forms, is passed from the application to the back end SQL database and executed as code.  Typically a form is looking to receive information to build a SQL query, but with SQL injection an attacker is able to enter characters or strings that are actually valid commands within the Structured Query Language.

Blind SQL injection is slightly different in that the attacker does not have any direct indication that the application is susceptible to SQL injection.  Rather, the attacker must ask the application true/false questions and determine the validity of the answer based on the application?s response.  For example an attacker may send data known to elicit a ?false? response then contrast that with data known to elicit a ?true? response and based off of this, the attacker can distinguish when other queries are true or false.

Risk
If untrusted user data that is accepted and not validated or sanitized, then depending on the query that is built, the database may execute the inputted data as query code, return unauthorized data from database, modify the database in some way, or escape the database entirely and store and execute code on the underlying server.

Recommendation and Resources
Whitelisting ? the defining of the universe of approved or acceptable characters only ? is the recommended way to avoid SQL injection.  Some applications require special characters and therefore whitelisting is not feasible.  In this case the preferred option is to use the built-in secure code libraries in the programming language?s framework (see the Software Security Standards link below).  

https://docs.company.com/display/SS/Software+Security+Standards%2C+Guidelines+and+Best+Practices
https://www.owasp.org/index.php/Blind_SQL_Injection
https://www.owasp.org/index.php/SQL_Injection_Prevention_Cheat_Sheet

LDAP Injection
Description
LDAP injection occurs when LDAP statements or queries are created based on user input that has not been properly validated or sanitized.  The user input usually comes from a web form and is passed directly to the LDAP query, however, if an attacker can enter special characters, the query that is generated could be significantly different than what the developer intended.  For example, if a web form is asking for a username but the attacker enters a ?*?, then it is possible that all usernames from the LDAP store would be returned as the result.

Risk
If untrusted user data that is accepted and not validated or sanitized, then depending on the LDAP query that is built, the LDAP server may execute the inputted data as query code, return unauthorized data, modify the LDAP store in some way, or escape the LDAP service entirely and store or execute code on the underlying server.

Recommendation and Resources
Whitelisting ? the defining of the universe of approved or acceptable characters only ? is the recommended way to avoid LDAP injection.  Some applications require special characters and therefore whitelisting may not be feasible.  In this case the preferred option is to use the built-in secure code libraries in the programming language?s framework (see the Software Security Standards link below).  

https://docs.company.com/display/SS/Software+Security+Standards%2C+Guidelines+and+Best+Practices
https://www.owasp.org/index.php/LDAP_injection
http://projects.webappsec.org/w/page/13246947/LDAP%20Injection

XML Injection
Description
XML injection occurs when XML statements or queries (also known as XPath queries) are created based on user input that has not been properly validated or sanitized.  The user input usually comes from a web form and is passed directly to the XML interpreter, however, if an attacker can enter special characters, the query that is generated could be significantly different than what the developer intended.  For example, if a web form is registering a new user but the attacker is able to enter <!--then it is possible that XML elements may be commented out and new elements inserted at the attacker?s discretion.

Risk
XML injection can lead to numerous issues including but not limited to: mal-formed XML documents, cross-site scripting (XSS), system crash leading to denial of service, or incorrect record injection.

Recommendation and Resources
Whitelisting ? the defining of the universe of approved or acceptable characters only ? is the recommended way to avoid XML injection.  Some applications require special characters and therefore whitelisting may not be feasible.  In this case, disabling document type definitions (DTDs) as well as using a well-known (not custom or internally developed) XML parser framework specific to the application is acceptable as a last resort.

Link Injection
Description
The application fails to validate or sanitize user input which allows an attacker to embed a URL to an external site within the application.  It is possible to cause a user's browser to issue automatic requests to virtually any site the attacker desires.  As a result, Link Injection vulnerability can be used to launch several types of attack including: CSRF, XSS, and phishing.

Risk
Damages can include stealing or manipulating users? sessions as well as altering records.  Additionally, the sites that are injected may be phishing sites therefore users could be tricked into divulging sensitive information such as usernames and passwords, leading to additional account or even system compromise.

Recommendation and Resources
Only allowing necessary characters (whitelisting) is the best defense for link injection.  For example, if only digits are expected in a particular field, the application should only whitelist the 10 characters 0-9.  Likewise, if only alphabet characters are expected, the application should produce an error if anything else is received.  Validation and sanitization can also help defends against XSS.  It is recommended to use the built-in secure code libraries in the programming language?s framework (see the Software Security Standards link below).
https://docs.company.com/display/SS/Software+Security+Standards%2C+Guidelines+and+Best+Practices
https://www.owasp.org/index.php/XSS_%28Cross_Site_Scripting%29_Prevention_Cheat_Sheet

Command Injection
Description
The application fails to validate or sanitize user input which allows an attacker to execute commands on the server in the context of the application or service account the application is running as.  Because this input is not validated, the input can escape the intended web function and begin to execute commands directly on the server.  These commands are specific to the underlying operating system ? such as Windows or Linux ? of the application server and can do any number of things depending on what commands are available.

Risk
Command injection is one of the most critical vulnerabilities.  This vulnerability allows an attacker to do anything on the server as though they are logged into it as a local user.  For example, an attacker could create or delete files, create listeners, upload keyloggers, or attack other internal systems.

Recommendation and Resources
User input into any field should always be considered untrusted and therefore sanitized by the application.  Whitelisting ? the defining of the universe of approved or acceptable characters only ? is the recommended way to avoid command injection.  If this is not possible because the input field may require the use of special characters then the preferred option is to use the built-in secure code libraries in the programming language?s framework (see the Software Security Standards link below).  

https://docs.company.com/display/SS/Software+Security+Standards%2C+Guidelines+and+Best+Practices
https://www.owasp.org/index.php/Command_Injection

Input Validation Misconfiguration
Description
The application fails to properly validate or sanitize user input.  Because this input is not validated, malformed data may be able to enter the system or escape the intended web function which in turn may lead to further exploitation.  This vulnerability demonstrates that input validation was either entirely neglected or was insufficient.  Further, if an application allows file upload but does not check the file metadata or content, this is also a type input validation misconfiguration known as ?unrestricted file upload.?

Risk
While this Input Validation Misconfiguration may not specifically lead to an Injection or XSS exploit, an attacker with sufficient time and resources could continue to ?fuzz? the parameter until it does lead to another vulnerability.  Alternatively, an attacker could compromise the integrity of the data in the system by being allowed to enter malformed data or upload malicious content due to missing file checks.

Recommendation and Resources
User input into any field should always be considered untrusted and therefore sanitized by the application.  Whitelisting ? the defining of the universe of approved or acceptable characters only ? is the recommended way to avoid malformed data from entering the system.  If this is not possible because the input field may require the use of special characters then the preferred option is to use the built-in secure code libraries in the programming language?s framework (see the Software Security Standards link below).  

https://docs.company.com/display/SS/Software+Security+Standards%2C+Guidelines+and+Best+Practices
https://www.owasp.org/index.php/Data_Validation
https://www.owasp.org/index.php/Input_Validation_Cheat_Sheet
https://www.owasp.org/index.php/Unrestricted_File_Upload


Note to the AVA Analyst (DO NOT INCLUDE THIS IN YOUR REPORT):
While this vulnerability is filed under A1, consideration was taken into account on whether it should instead be filed under A3 or even A6 due to the vulnerabilities it could lead to.  It was decided that though it is not specific to either A1 Injection or A3 XSS, it would be filed under A1 Injection simply because there are more types of Injection vulnerabilities.  Ultimately it was noted that filing it under A1 or A3 is irrelevant to the BUs because when the vulnerability is added to Archer ITGRC, the A# heading will not be included; this organization mechanism is simply for the AVA teams cross-reference with the OWASP Top 10.
 

A2 ? BROKEN AUTHENTICATION AND SESSION MANAGEMENT
Authentication Bypass
Description
In the event a user is able to somehow circumvent the authentication process then the application is susceptible to authentication bypass.  Also, authentication bypass differs from misuse of authorization in that the former allows access to the application despite not satisfying the rights of that account to use the application in any manner, whereas the latter allows an account to do more than they should be able to do based on their role or permissions.  Authentication is the verification that someone is who they claim to be.

Risk
Authentication bypass is a serious because the checks for verifying who is allowed to use the system are compromised.  This can lead to additional confidentiality, integrity, or accessibility issues based on what the attacker does after accessing the system illegitimately.  Additionally, the auditing controls for the application (if they exist) could be undermined because the appropriate authentication did not take place.

Recommendation and Resources
Use the corporate authentication infrastructure to protect the application.  If the application cannot use the corporate authentication mechanism, the application must ensure direct page access, parameter modification, session ID prediction, and SQL injection are all not possible through any means.

https://www.owasp.org/index.php/Authentication_Cheat_Sheet
https://www.owasp.org/index.php/Testing_for_Bypassing_Authentication_Schema_(OTG-AUTHN-004)

Logout Functionality Missing
Description
A logout button provides a method for the end-user to gracefully end their session and clear all session cookies without requiring them to close their browser.  This functionality is important because for the timeframe between when the user leaves the website and when the cookies timeout, if the user continues to other (potentially unsecured websites) the session information can be sniffed and stolen.
Risk
A malicious actor who has stolen session information can use that to access the website.  This gives them access to the application, records, or settings that the victim has access to.  This can lead to loss of sensitive information, record modification, change of account authorization, or other integrity issues.
Recommendation & Resources
Use the corporate banner that contains a logout button, or utilize the corporate logout functionality to provide users a method for ending their sessions.
https://www.owasp.org/index.php/Session_Management_Cheat_Sheet#Logout_Button
Session Expiration Missing
Description
The application fails to expire the session after a specified amount of time.  The corporate standard is to invalidate an authenticated session with an application after 20 minutes of inactivity.  The purpose of this control is to ensure that if someone uses the application on a public computer or neglects to lock their computer, any session they had with an application will automatically log them off.

Risk
The risk is that if someone is not automatically logged off then an attacker who happens to use the same computer can usurp that user?s session and continue interacting with the application as though he/she is the victim user.  This vulnerability can lead to the ability of the attacker to do anything the victim is able to do including possibly account take over, record manipulation, or unauthorized access to sensitive data.

Recommendation and Resources
It is recommended that the application invalidate any session that is inactive for 20 minutes.  This would be controlled on the server-side and the timer would start from the period of the last HTTP request to the application.

https://www.owasp.org/index.php/Session_Management_Cheat_Sheet#Automatic_Session_Expiration
https://www.owasp.org/index.php/Session_Timeout

Session Invalidation Misconfiguration
Description
Session management defines how a continuous session between a client and server will be maintained.  This continuous session can be done via cookies, URL parameters or arguments, HTTP headers, or some other method.  At the conclusion of the session, the method by which it was maintained must either cease to exist or be altered in such a manner so that the same session cannot be reused or re-instantiated.

In this case, the application fails to either sufficiently destroy the cookies or other session mechanism and therefore the session can be inappropriately continued.

Risk
A user may believe by logging off the application that their session is terminated and the next user of the application will need to re-authenticate.  The risk is that the session invalidation is not correct and therefore the next user of the application could effectively become the first user and persist his/her session.  This vulnerability can lead to the ability of the attacker to do anything the victim is able to do including possibly account take over, record manipulation, or unauthorized access to sensitive data. 

Recommendation and Resources
If possible, use the corporate authentication framework so that it does not need to be handled by the application directly.  If authentication must be done at the application level, upon logout or session expiration that all session cookies are destroyed and any other mechanism used to maintain session are sufficiently altered.

https://www.owasp.org/index.php/Session_Management_Cheat_Sheet

Account Lockout Functionality Misconfiguration
Description
Authentication is the means by which an application validates that a user is who they claim to be.  An application must track authentication attempts in order to ensure an attacker is not allowed to brute force their way into the application.  Should the application detect that a user or attacker has entered a series of incorrect passwords; the associated account must become locked until an administrator has reviewed the issue ? or less ideally a specific duration of time has elapsed ? before that account can once again attempt authentication.  In this case, the application does not lockout the account as described.

Risk
Not having an account lockout mechanism leaves the application vulnerable to brute force attacks.  This may in turn lead to an attacker inappropriately gaining access to the application at whatever level the account is that they have brute forced; typically attackers go after administrative accounts for the obvious reason that they have more permission.

Recommendation and Resources
Ensure the application tracks (audits) the number of login attempts for each account.  Best practice dictates that three to five authentication attempts is a reasonable threshold before locking an account, but this will depend on the type of data the application houses and the user community of the application.  It is ISR?s recommendation to not permit more than five attempts before the account locks.

https://www.owasp.org/index.php/Blocking_Brute_Force_Attacks
https://www.owasp.org/index.php/Authentication_Cheat_Sheet#Prevent_Brute-Force_Attacks

Default Credentials
Description
Default credentials may be used to assist in the installation and implementation of third-party software.  This application uses default credential to allow successful authentication.  These credentials are documented, well known, and used anywhere the same third-party software is installed, even external to the enterprise.

Risk
An attacker can gain access to the application through the use of these default credentials.  Additionally, these default credentials are for admin level access so the attacker will have administrative privileges.  This can lead to any number of issues including creating persistent accounts, record manipulation, or unauthorized access to sensitive data.

Recommendation and Resources
If this application has been publicly available with these default credentials enabled, it is ISR?s recommendation to first perform a full incident response with the corporate Operations Support team.  If the application is has only been available internally, a review of logs should be conducted to see if the default account has been used.  The default credentials must be changed and due to auditing policies, it should not be used so that changes may be attributed to an actual, individual user.

Hardcoded Password
Description
The application includes a hardcoded password in its source code.  This password can be discovered either by public disclosure or reverse engineering the software.  Additionally, because it is hardcoded, in order to make a change to the password ? which is good security practice ? it would require an update to the entire application.

Risk
Depending on what the password in the application was trying to protect, the risk could be very high.  For instance if it is connecting to a database, then an attacker could login to the database as the service account using the hardcoded password and perform any actions on the database which should only be limited to the service account.

Recommendation and Resources
Rather than hardcoding the password in the application, rewrite that portion of the application to have it read a configuration file which maintains an encrypted password.  If it is a vendor supplied application, work with the vendor to remove the hardcoded password and supply an updated version of the software.

Secure Flag Not Set on Session Cookies
Description
Setting the secure flag on a cookie informs the client web browser to not send the cookie over unencrypted connections, helping keep the cookie value confidential.  Failure to set this flag allows the application to send the session ID in clear text across the Internet.  Sending cookies over an unencrypted channel exposes them to network sniffing attacks.

Sniffing or monitoring unencrypted traffic is trivial for an attacker, so sending session cookies over unencrypted channels leave them at risk of being captured.

The following cookies are missing the secure flag:
?	
Risk
Attackers without valid credentials to the application gain the ability to access/modify confidential data, such as account information, by ?stealing? the session ID of a currently logged in user.

An attacker appropriately located could simply monitor network traffic and is able to see the authenticated user?s session cookies as they travel across the network.  He then captures and replays these cookie and is able to take over the user session, effectively giving himself permissions equal to that of the legitimate user.

Recommendation & Resources
Include this attribute within the relevant Set-cookie directive on the application or web server.
https://www.whitehatsec.com/blog/session-cookie-secure-flag-java/
https://portswigger.net/KnowledgeBase/issues/Details/00500200_SSLcookiewithoutsecureflagset
http://www.owasp.org/index.php/Top_10_2010-A9


Session Hijacking
Description
Session hijacking is a vulnerability by which the session management of the application is incorrectly configured or implemented.  When a user connects to the application they receive a session ID; if an attacker can either steal or predict the session ID, then the attacker can connect to the application with that same session ID.

Another variation on this vulnerability is when the application issues a session ID pre-authentication (which may be sniffed), but then fails to change the session ID post-authentication.  In this scenario, the attacker simply can use the pre-authentication token as a post-authentication token and get unauthorized access.

Risk
If a session is hijacked, the application server cannot distinguish between the legitimately authenticated user and the attacker.  Therefore anything the victim user can do, the attacker would also be able to do up to and including full system compromise.

Recommendation and Resources
Use the enterprise authentication framework; if this is infeasible, use a generic, but well defined and tested framework for session management which should include: that all session IDs are submitted over an encrypted connection.  That sensitive cookies have the secure and HttpOnly flag set to indicate they are only to be transmitted to a browser and only over a secure connection.  

https://www.owasp.org/index.php/Session_hijacking_attack
https://www.owasp.org/index.php/Session_fixation
https://www.owasp.org/index.php/OWASP_Periodic_Table_of_Vulnerabilities_-_Cookie_Theft/Session_Hijacking
 
A3 ? CROSS-SITE SCRIPTING (XSS)
Cross-Site Scripting (XSS) - Stored
Description
Cross-site scripting (XSS) is a type of injection whereby malicious code is sent to an end user and the user?s browser trusts the content sent from the server.  The two most prominent types of XSS are stored and reflected: stored XSS is when the malicious script is stored on the server and a user browses to a site that hosts the script.  When the page is rendered, the stored XSS vulnerability is exploited.  Conversely, reflected XSS is when a user is tricked into clicking a link or submitting a specially crafted form and the malicious code is reflected off of the vulnerable server.

Risk
Getting a browser to issue a pop-up alert is a simple demonstration of the vulnerability but it does not demonstrate the real risk associated with XSS.  Cookie stealing, session hijacking, keylogging, account take over, installation of Trojan horse programs, etc. are all possible risks associated with XSS.

Recommendation and Resources
Only allowing necessary characters (whitelisting) is the best defense for XSS.  For example, if only digits are expected in a particular field, the application should only whitelist the 10 characters 0-9.  Likewise, if only alphabet characters are expected, the application should produce an error if anything else is received.  Validation and sanitization can also help defends against XSS.  It is recommended to use the built-in secure code libraries in the programming language?s framework (see the Software Security Standards link below).
https://docs.company.com/display/SS/Software+Security+Standards%2C+Guidelines+and+Best+Practices
https://www.owasp.org/index.php/XSS_%28Cross_Site_Scripting%29_Prevention_Cheat_Sheet
http://www.acunetix.com/websitesecurity/cross-site-scripting/
https://www.owasp.org/index.php/Testing_for_Reflected_Cross_site_scripting_%28OTG-INPVAL-001%29
https://www.owasp.org/index.php/Testing_for_Cross_site_scripting


Cross-Site Scripting (XSS) - Reflected
Description
Cross-site scripting (XSS) is a type of injection whereby malicious code is sent to an end user and the user?s browser trusts the content sent from the server.  The two most prominent types of XSS are stored and reflected: stored XSS is when the malicious script is stored on the server and a user browses to a site that hosts the script.  When the page is rendered, the stored XSS vulnerability is exploited.  Conversely, reflected XSS is when a user is tricked into clicking a link or submitting a specially crafted form and the malicious code is reflected off of the vulnerable server.

Risk
Getting a browser to issue a pop-up alert is a simple demonstration of the vulnerability but it does not demonstrate the real risk associated with XSS.  Cookie stealing, session hijacking, keylogging, account take over, installation of Trojan horse programs, etc. are all possible risks associated with XSS.

Recommendation and Resources
Only allowing necessary characters (whitelisting) is the best defense for XSS.  For example, if only digits are expected in a particular field, the application should only whitelist the 10 characters 0-9.  Likewise, if only alphabet characters are expected, the application should produce an error if anything else is received.  Validation and sanitization can also help defends against XSS.  It is recommended to use the built-in secure code libraries in the programming language?s framework (see the Software Security Standards link below).
https://docs.company.com/display/SS/Software+Security+Standards%2C+Guidelines+and+Best+Practices
https://www.owasp.org/index.php/XSS_%28Cross_Site_Scripting%29_Prevention_Cheat_Sheet
http://www.acunetix.com/websitesecurity/cross-site-scripting/
https://www.owasp.org/index.php/Testing_for_Reflected_Cross_site_scripting_%28OTG-INPVAL-001%29
https://www.owasp.org/index.php/Testing_for_Cross_site_scripting

Cross-Site Scripting (XSS) - DOM-Based
Description
DOM-based XSS vulnerability controls the flow of the code by using elements of the Document Object Model (DOM) along with code crafted (eg. a URL) by the attacker to change the flow.  This type of XSS vulnerability is unique compared to typical stored or reflected XSS in that it does not require a malicious payload to be embedded in the HTML page.

The web page itself does not change but client-side code executes differently due to changes that have occurred in the DOM, potentially done by an attacker.

Risk
The risk of this type of XSS is identical to other types of XSS ? cookie stealing, session hijacking, account take over, installation of Trojan horse programs, etc .

Recommendation & Resources
Do not dynamically write untrusted data ? such as a URL ? into the controllable part of the DOM.

https://www.owasp.org/index.php/Testing_for_DOM-based_Cross_site_scripting_%28OTG-CLIENT-001%29
https://www.owasp.org/index.php/DOM_Based_XSS
http://www.webappsec.org/projects/articles/071105.shtml

 
A4 ? INSECURE DIRECT OBJECT REFERENCES
Backup [File|Firmware] Available without Authentication
Description
A backup copy of the application (or firmware) is available without authentication.  This copy has the potential to include sensitive information.

Risk
Risk is dependent on what is included in the backup

Recommendation and Resources
Do not host any backup or testing material in the PROD environment.  All development changes should be made in the TEST environment and removed from the master copy before being pushed to PILOT.

Update [File|Firmware] Available without Authentication
Description
An update to the application (or firmware) is available without authentication.  This copy has the potential to include sensitive information.

Risk
Risk is dependent on what is included in the backup and/or if the update can be applied without authentication.

Recommendation and Resources
Do not host any backup or testing material in the PROD environment.  All development changes should be made in the TEST environment and removed from the master copy before being pushed to PILOT.


 
A5 ? SECURITY MISCONFIGURATION
Application Fails to Use HTTPS
Description
SSL/TLS is an encryption mechanism designed to protect information as it travels across networks, including those networks not owned by company.  HTTPS is a protocol specific to web traffic that uses SSL/TLS; conversely HTTP is a similar protocol that does not use any form of encryption.

Risk
HTTPS protects against unauthorized disclosure of information and provides confidentiality for all application information.  The risk of not using HTTPS includes the disclosure of any/all records within the system to unauthorized third-parties.  By not using HTTPS, user?s sessions are also at risk of man-in-the-middle (MitM) attacks.  If an attacker were to steal a user session, which could be leveraged to gain access to the company Intranet or any other company system-wide single sign-on application.

Recommendation & Resources
To properly protect the data within this application from unintended disclosure, the entire application should be protected by SSL/TLS through the use of HTTPS.  The application should not downgrade the connection from HTTPS to HTTP after authentication, but rather continue using a HTTPS connection.  Additionally, while SSL and TLS are often used interchangeably, in fact TLS is the only acceptable protocol that should be used and the minimum version should be no less than TLS 1.1.

SSL/TLS Certificate Misconfiguration
Description
SSL/TLS certificates are issued by Certificate Authorities who have validated the identity of the certificate recipient.  The certificates are then used to create an encrypted channel of communication between the client and the application.  If there is a mismatch between the name on the certificate issued by the CA and the application, then the client browser will issue a warning.  Likewise, if the application server is using an outdated algorithm or weak cryptographic cipher, the client browser will either not connect or issues a warning.  Finally, SSL and TLS are typically used interchangeably; however the current standard for secure HTTP communication is to use only TLS and only use TLS version 1.1 or higher.

Risk
There are many risks associated with TLS certificate misconfiguration including: ?monkey-in-the-middle? downgrade attacks which allow an attacker to intercept HTTP communication.  Clients? browsers may also downgrade to weak cipher for communication which could make eavesdropping a secure channel easier.  Or lastly, there is simply the brand damage of clients using the application and getting certificate warnings ? this demonstrates a lack of quality assurance.

Recommendation and Resources
Ensure the application is using TLS 1.2 or higher for HTTPS communication.  Ensure the Certificate Authority that issued the certificate is well-known and included in browsers by default.  Ensure the application URL domain and/or sub-domain matches the name on the certificate.

Encryption Protocol or Cipher Suite Misconfiguration
Description
Sensitive data, whether it is at rest or in transit, should be encrypted. SSL/TLS is a collection of protocols. Weaknesses have been identified with earlier SSL protocols, therefore only TLS protocols should be used.  For each protocol there is a selection of cryptographic ciphers suites and the strength of the encryption depends on the ciphers used.  The server and client will negotiate which suites both endpoints are capable of using, so it is recommended that the server only present strong cryptographic ciphers during this negotiation period.

Risk
An attacker may be able to force the server-client connection to use a weak cipher via a man-in-the-middle attack and break the encrypted communication.  From there she could disclose secret text such as session cookies which will lead to session hijacking.

Recommendation and Resources
Only use TLS, preferably version 1.2.  Only enable and use company?s recommended strong cipher suites on all communication endpoints including web services.

https://docs.company.com/display/SS/Encryption+Algorithm+Selection+Guide
https://www.owasp.org/index.php/Transport_Layer_Protection_Cheat_Sheet#Server_Protocol_and_Cipher_Configuration

Browser Exploit Against SSL/TLS (a.k.a. BEAST)
Description
BEAST is a vulnerability whereby the portion of the cryptographic algorithm used to mask data can be predicted by an active man-in-the-middle.  With enough guesses, an attacker who can see what the encrypted data looks like, any amount of data can be uncovered.
BEAST is a client-side vulnerability that has been mitigated in most modern browsers; however, there is potentially a substantial number of older browsers that still in use and therefore vulnerable.  In order to protect anyone using these browsers, BEAST can and should be mitigated from the server-side as well.

Risk
An appropriately situated attacker could predict the initialization vector of the algorithm used to encrypt data and could therefore unencrypt communications leaving employee information at risk.

Recommendation & Resources
Only use TLS and strong cryptographic algorithms used as part of SSL/TLS.  See the first resources link below for a list of recommended ciphers.

https://blogs.msdn.microsoft.com/kaushal/2011/10/03/taming-the-beast-browser-exploit-against-ssltls/
https://blog.qualys.com/ssllabs/2013/09/10/is-beast-still-a-threat

HTTP Method Tampering
Description
GET and POST are HTTP methods accepted by the application.  GET requests are designed to query the server, while POST requests are for submitting data.  In order to attack body parameters (those sent in POST requests) an attacker would need to create an independent page with a form and get a user to submit the form.  Attacking query parameters (those sent in a GET request) is easier than body parameters because the parameters are sent to the original site.  Therefore it is not recommended to support body parameters that arrive in the query string.  

Risk
Allowing a GET request with body parameters as query data makes attacking the application easier.  This is also a type of information disclosure and can lead to a na?ve user disclosing sensitive information.

Recommendation & Resources
Require that the application reject GET requests with POST parameters listed in the query.

Arbitrary HTTP Methods Allowed
Methods or verbs are the functions that the web or application server accepts and responds to.  The most common ? and generally only needed ? of these is GET and POST however the HTTP specification defines all of the following:
OPTIONS
GET
HEAD
POST
PUT
DELETE
TRACE
CONNECT

Despite this fact, only those methods which the application requires should be accepted by the server and the other methods should be explicitly denied.
Currently the server allows GET, HEAD, POST, PUT, DELETE, TRACE, and OPTIONS.
Risk
Methods that potentially allow addition or deletion of files from the server are considered dangerous and should be explicitly denied unless a business case requires them; and in this case only allowed to a very specific page.  The risk is that an attacker can put a malicious file on the server which would then be hosted as part of the application.  An example would be to replace financial pages with a malicious page that captures banking information or personally identifiable information.  Alternatively, the attacker could delete files from the server which would then cause a denial of service condition for valid users.

Recommendation and Resources
Explicitly disable all HTTP methods except GET and POST unless specifically needed and then only enable them on very specific pages.
https://www.owasp.org/index.php/Testing_for_HTTP_Verb_Tampering_%28OTG-INPVAL-003%29
http://www.aspectsecurity.com/research-presentations/bypassing-vbaac-with-http-verb-tampering

Cacheable SSL/TLS Pages
Description
The application allows caching of SSL pages, which enables the user to view previously accessed pages even after logout. A user accomplishes this by hitting the browser back button after a previous user of the application logs out and leaves the browser open.  This also can be accomplished by looking at the temp directory to see what ? if any ? documents may have been downloaded

Risk
For public documents, this risk is fairly low. However, cache-control headers should be updated if this service will be used to download internal only or confidential documents. It should be noted that the information view through a cached page cannot be updated.

Recommendation and Resources
Disable caching on all SSL pages.  One method is to add ?Cache-Control: no-cache, no-store? to the application request headers.

Cross Frame Scripting Defense Header Misconfiguration
Description
Cross-Frame Scripting is where an attacker loads a vulnerable application in an iFrame on his malicious site.  The attacker can then launch a Clickjacking attack, which may lead to phishing, Cross-Site Request Forgery, sensitive information leakage, and more.  Essentially the vulnerable site is embedded in an attacker?s site and a user is enticed to visit the attacker?s website thinking that they are actually visiting the vulnerable application.

Risk
When no X-Frame-Options header is set by the server the user can fall victim to ?clickjacking? and perform unintended actions thereby potentially revealing confidential information or modifying records or user settings.

Recommendation & Resources
Add an X-Frame-Options header to all responses from the server, preferably set to DENY.
By setting the X-Frame-Options header with a value, this prevents the other pages from framing the application web site.  SAMEORIGIN or DENY states that only sites of the same domain may frame the page or no sites (regardless of the domain) may frame the page, respectively.
https://www.owasp.org/index.php/Cross_Frame_Scripting
https://www.owasp.org/index.php/Clickjacking_Defense_Cheat_Sheet
https://www.owasp.org/index.php/Testing_for_Clickjacking_%28OTG-CLIENT-009%29

Content-Security-Policy (CSP) Header Misconfiguration
Description
The "Content-Security-Policy" (CSP) header is designed to modify the way browsers render pages, and thus to protect from various cross-site injections, including Cross-Site Scripting.  This specification offers the possibility to instruct the client browser from which location and/or which type of resources are allowed to be loaded.
The following pages were missing the ?Content-Security-Policy? header
?	

Risk
Content-Security-Policy is used to prevent cross-site scripting (XSS), clickjacking and other code injection attacks resulting from execution of malicious content in the trusted web page context.  Not having a CSP defined increases the risk that these types of attacks can be used against this application.
Implementing the CSP across a large site can be difficult and time consuming because various pages may require some degree of JavaScript.  Care should be taken when implementing the CSP.

Recommendation and Resources
If feasible, create a custom CSP HTTP response header, which will apply to all content on a server or in a site or application.

https://www.owasp.org/index.php/Content_Security_Policy

X-Content-Type-Options Header Misconfiguration
Description
The ?X-Content-Type-Options? header (with "nosniff" value) prevents IE and Chrome from ignoring the content-type of a response.  This action may prevent untrusted content (e.g. user uploaded content) from being executed on the user browser.
The following pages were missing the ?X-Content-Type_Options? header

?	
Risk
If a malicious user is able to upload content, including the ?X-Content-Type-Options? header reduces exposure to drive-by download attacks and sites serving that uploaded content.

Recommendation & Resources
Include an ?X-Content-Type-Options? header with the value of "nosniff".  This will prevent Internet Explorer and Google Chrome from MIME-sniffing a response away from the declared content-type.

https://www.owasp.org/index.php/List_of_useful_HTTP_headers

X-XSS-Protection Header Misconfiguration
Description
The ?X-XSS-Protection? header forces the Cross-Site Scripting filter into Enable mode, even if disabled by the user.
This filter is built into most recent web browsers (IE 8+, Chrome 4+), and is usually enabled by default. Although it is not designed as first and only defence against Cross-Site Scripting, it acts as an additional layer of protection.

The following pages were missing the ?X-Content-Type_Options? header

?	

Risk
This protection is built into modern browsers and enabled by default; a user would have to explicitly disable it.  Because of this, the relative risk of this vulnerability is very low.

Recommendation & Resources
Include an ?X-XSS-Protection? header with the value of ?1; mode=block? (ie. enabled and block) on all outgoing requests.

HttpOnly Flag Not Set on Cookies
Description
HttpOnly is an additional flag included in a Set-Cookie HTTP response header. Using the HttpOnly flag when generating a cookie helps mitigate the risk of a client side script accessing that protected cookie.  The majority of XSS attacks target theft of session cookies. A server could help mitigate this issue by setting the HttpOnly flag on any cookie it creates, indicating the cookie should not be accessible to scripts.

Risk
The risk of session theft via XSS is higher.

Recommendation & Resources
Unless a script or other application requires access to the DOM document.cookie object, add the HttpOnly flag response header when setting a cookie.

https://www.owasp.org/index.php/HttpOnly
https://www.owasp.org/index.php/Session_Management_Cheat_Sheet#HttpOnly_Attribute

HTTP Strict Transport Security (HSTS) Header Misconfiguration
Description
HTTP Strict Transport Security (HSTS) is a mechanism which protects secure (HTTPS) websites from being downgraded to non-secure HTTP. This mechanism enables web servers to instruct their clients (such as web browsers) to use secure HTTPS connections when interacting with the server, and never use the insecure HTTP protocol.  Many websites do not use TLS/SSL, therefore there is no way of knowing (without prior knowledge) whether the use of plain HTTP is due to an attack, or simply because the website hasn't implemented TLS/SSL.  The HSTS header is set on the server side.

Risk
The most important security vulnerability that HSTS can fix is SSL-stripping man-in-the-middle attacks; so not including the HSTS header allows for the potential of these types of attacks.
HSTS addresses the following threats:	

?	User bookmarks or manually types http://example.com and is subject to a man-in-the-middle attacker
o	HSTS automatically redirects HTTP requests to HTTPS for the target domain
?	Web application that is intended to be purely HTTPS inadvertently contains HTTP links or serves content over HTTP
o	HSTS automatically redirects HTTP requests to HTTPS for the target domain
?	A man-in-the-middle attacker attempts to intercept traffic from a victim user using an invalid certificate and hopes the user will accept the bad certificate
o	HSTS does not allow a user to override the invalid certificate message

Recommendation & Resources
Implement an HSTS on response headers coming from the web application.  The ?preload? setting is optional but recommended.
Strict-Transport-Security: max-age=31536000; includeSubDomains; preload

https://en.wikipedia.org/wiki/HTTP_Strict_Transport_Security
https://www.owasp.org/index.php/HTTP_Strict_Transport_Security
Email Spoofing
Description
The application, by design, asks for a FROM email address.  It then uses this FROM address on the automated email it sends.  Because this FROM address can be anything, a malicious user could enter a legitimate seeming email address or an email address from someone other than him/herself.  This can make a phishing email seem more legitimate and increase the likelihood people will click on it (using the above vulnerability), the malicious user could enter known ?safe? email addresses or email addresses from C level executives.

Risk
The true risk of this is when it is coupled with an email that contains a phishing link.  Because this application also has Link Injection vulnerability, it makes those phishing emails appear much more legitimate, especially because phishing training includes reviewing the senders email address.

Recommendation & Resources
It would be best if the application was redesigned to not include a FROM address entry field, but rather automatically sent from a specific, safe address.

https://en.wikipedia.org/wiki/Email_spoofing


Directory Traversal
Description
By manipulating parameters that access files, an attacker can force the application to display other files that are stored on the server or an external source. The use of ?../? will allow a hacker to navigate up through the directories and access files stored in other directories. The URL could also be pointed at an external website to load data onto the current page.

Risk
An attacker may be able to gain access to sensitive files that should not be accessible to anyone logged in to the application. A malicious user also may be able to run executable files that are stored on the server. It may be possible to point the URL at a page that can run Javascript and that code would be executed on the page.

Recommendation and Resources
Reject any input that this not whitelisted on input fields.  Additionally, verify the appropriate access control lists (ACLs) are being used on the file system to jail the web application into a specific directory and the service account under which the application is running does not have any access outside this jail.

https://www.owasp.org/index.php/Path_Traversal

Application Denial of Service (DoS)
Description
A denial of service (DoS), as the name implies, prohibits access to data or an application in entirety.  Availability is one of the three core tenants of information security and a DoS attack limits that availability.

Risk
When an application or data is not available, the risk is that potential customers/clients will not be able to use the application. This will reflect poorly on company as a brand or if the application is internal, limit the ability of business partners to promptly and accurately provide services.

Recommendation and Resources
Recommendations are dependent on the root cause of the DoS.
 
A6 ? SENSITIVE DATA EXPOSURE
Sensitive Data Stored Unencrypted
Description
Sensitive data, whether it is at rest or in transit, should be encrypted.

Risk
An attacker will try to gain access to information either stored in a database or in the source code, or she will try to capture network traffic.  If either of these is unencrypted then it becomes trivial to use this information to gain additional access, modify or destroy records, or add unauthorized permissions.

Recommendation and Resources
Sensitive data should always be encrypted.  It is ISR?s recommendation that the application use HTTPS for all network communication.  When sensitive data is at rest, whether it is in code or as data in a database, this should be encrypted with an algorithm and/or key length commensurate with the sensitivity of the data.

https://www.owasp.org/index.php/Cryptographic_Storage_Cheat_Sheet
https://www.owasp.org/index.php/Guide_to_Cryptography

Hardcoded Encryption Keys
Description
The application includes a hardcoded encryption key in its source code.  This key can be discovered either by public disclosure or reverse engineering the software.  Additionally, because it is hardcoded, in order to make periodic changes to the key ? which is good security practice ? it would require an update to the entire application.

Risk
Depending on what the key in the application is trying to protect, the risk could be very high.  Because this key can decrypt anything that has been encrypted with it, having it hardcoded makes changing the cypher text to clear text trivial.  Additionally, if this key is not changed between instances of the application, then an attacker could decrypt encrypted files anywhere based on this hardcoded key.

Recommendation and Resources
Rather than hardcoding the key in the application, rewrite that portion of the application to have it read a configuration file which maintains the key.  This configuration file should have strict file system ACLs to only allow necessary access.  If it is a vendor supplied application, work with the vendor to remove the hardcoded key and supply an updated version of the software.

Information Disclosure
Description
Information disclosure is when an application or web page reveals information that an attacker could use to assist in exploiting an application.  Information disclosure is generally found in comments within the code or HTML of the web page or due to information leaked due to unhandled errors in the application.  Even though they are comments and not rendered by a browser, they are easily visible by either viewing the source or by using an attack tool such as an interception proxy.  In this case, the backend application server and database information is being revealed.

The following pages have information disclosure issues:
?	

Risk
The risk of information disclosure depends on what is being disclosed.  Disclosure reduces the time and/or effort it requires for an attacker to exploit a system.  With unlimited time and resources, an attacker can focus his efforts on exploiting details listed in the disclosed information.

Recommendation & Resources
All comments should be removed before the code is promoted to Production.  All errors that are returned back to the user should be generic in nature and not disclose the reason why the error occurred; this can be accomplished through custom error pages.  As best practice, web servers can have custom pages based on the HTTP response code it would like to send.

https://www.owasp.org/index.php/Information_Leakage

Application Design Document Issues
Description
The application does not follow the design document or the design document is out of date.

Risk
The application security is based off of the design document.  Having an application that does not follow the design document out or having a design document that is out of date could lead to additional vulnerabilities.  Additionally, in a disaster recovery scenario whereby the application must be rebuilt, having an application that does not follow the design document can lead to misconfigurations.

Recommendation and Resources
Update the design document and verify the application architecture matches that design document.

Username/Account Enumeration
Description
Account enumeration is the ability to gather a list of valid users from the system based on responses received.  For instance, entering a username to request a new password can tell us if that user (or username) exists on the system based on whether the application recognizes the username.

Risk
The risk to user enumeration is that an attacker can gather a list of valid users.  From there, this user list can be used for unauthorized access to the system and possibly account takeover.

Recommendation and Resources
The application should not disclose information about whether a username or account is valid within the system.  This means the response when a query is created for a valid user is identical to the response for an invalid user.  Additionally, the time it takes to receive that response should be identical; this means that identical user lookup and password hash queries should be run against the database regardless of whether the username is valid.

Sensitive Input Fields Not Masked
Description
Sensitive fields should be masked as the assumption is made that these contain confidential information.  By leaving the input viewable by anyone, a targeted user could be shoulder surfed (either physically or electronically) and the credentials stolen.

Risk
Malicious actor could steal the credentials and then inaccurately update the user record

Recommendation and Resources
Mask the input of the private data with ?***?.  If customers wish to be able to view the information they enter, it is possible to provide a checkbox for them to display these characters, but that should be the user decision.

Autocomplete Enabled
Description
Auto complete feature is implemented as simplicity for end user to enter the username, password and other information. Since this feature is insecure by design, this leaves user expose to leaking of sensitive information (login credentials, credit card information, PII data) locally.

Risk
If the auto complete feature id turned on through the application, browser stores the username , password or other sensitive information (e.g. a unique government identifier or credit card security code) locally in the client machine. This allows any adversary to get hold of such sensitive information, which can be used to launch attack against that user account.

Recommendation
It is strongly recommended to disable the use of this feature through application.  Implement the solution throughout the application?s login page and form fields.  The following HTML code segment can be used:
<input type=text autocomplete=?off?>

https://developer.mozilla.org/en-US/docs/Web/Security/Securing_your_site/Turning_off_form_autocompletion
https://www.rapid7.com/db/vulnerabilities/spider-sensitive-form-data-autocomplete-enabled

Query Parameter in SSL Request
Description
A query parameter is an input field that is passed to the application server via the URL, typically as a GET request.  Even though it is encrypted in transit, these parameters should not be sent in the request due to the possible sensitive nature.

Risk
Although HTTPS headers are encrypted over SSL/TLS, a query parameter should not be submitted in the request because those parameters may be stored in other locations.  For example, a query parameter sent via a GET request could be stored in a user?s browser history or in the web application logs and sometimes even a POST request?s body data is available to installed browser extensions.  Worse still, the query parameter could be forwarded in the referrer heading to another website (specifically ad networks or social media).

Recommendation
It is recommended to identify users based on session information and store sensitive data in a backend database.  If data must be submitted, it should in a POST request body.

http://www-01.ibm.com/support/docview.wss?uid=swg21883669
https://blog.httpwatch.com/2009/02/20/how-secure-are-query-strings-over-https/
 
A7 ? MISSING FUNCTION LEVEL ACCESS CONTROL
Arbitrary File Read Access
Description
The application is able to arbitrarily read files from the file system.

Risk
Depending on the contents of the file that is able to be read, this information could be extremely valuable especially if it contains PII, financial information, or account credentials that can be used to pivot further within the organization.

Recommendation and Resources
Configure the application to be run as a service account on the information system.  Verify the permissions that the service account has are limited to a set of directories and/or subdirectories but no more.  Confirm that the service account is not in any other file system groups and that the service account does not have login capabilities to the system.
Arbitrary File Write Access
Description
The application is able to arbitrarily write files to the file system.

Risk
If an attacker can write files to the file system, this could be leveraged to create a rootkit on the system, install software or keyloggers on the system, or steal credentials.  Alternatively, the attacker could modify or delete data, thereby compromising the integrity or availability of the data.

Recommendation and Resources
Configure the application to be run as a service account on the information system.  Verify the permissions that the service account has are limited to a set of directories and/or subdirectories but no more.  Confirm that the service account is not in any other file system groups and that the service account does not have login capabilities to the system.

Insufficient Physical Access Controls
Description
Because there are so many ways to access the underlying operating system when an attacker has physical access to a device, it should be assumed that they can do anything to the operating systems or any applications/firmware on the device.   There must be physical access controls in place to ensure an attacker cannot gain physical access to the device.  These include badge readers, doors with locks, iris scanners, etc.

Risk
Gaining physical access to a device is equivalent to having full root or administrative access to that device.  A new configuration file could be installed, a rootkit could be installed, or the entire device could be made unavailable through destruction.  With physical access, it can be assumed that the confidentiality, availability, and integrity of the device are all suspect.

Recommendation and Resources
Ensure that the device is secured behind multiple layers of physical defenses and only those who are authorized to access the device are permitted within physical proximity.  If the device must be in a shared or public space, then there must be compensating detection controls for alerting when a device has changed.

Improper Access Controls
Description
Access control is akin to authorization which is the permissions a subject is granted to interact with a specific object.  Authorization is typically policy driven and determined based on the identity of the user.  Improper access controls are settings or lack of settings that allow the user additional permissions they otherwise would not be allowed to do.

Risk
An attacker may be able to gain access to files that should not be accessible to her or an attacker may be able to add, modify, or delete files.

Recommendation and Resources
Properly implement the company of Least Privilege.  Through the use of role-based access controls (RBACs) or attribute-based access controls (ABACs), make sure a user of a given role can only access the information they are entitle to access and no more.  Validate that authorization checks are present and performed on the server side.

https://www.owasp.org/index.php/Top_10_2013-A7-Missing_Function_Level_Access_Control

Privilege Escalation
Description
Privilege escalation occurs when a user gets access to more resources or functionality than they are normally allowed.  There are two types of escalation: vertical ? the ability to access more resources or functionality than typically granted to a specific role; and horizontal ? the ability to access more resources of a similarly configured account.

Risk
For vertical escalation, an attacker may be able to modify his or her privileges and roles within the application, thereby gaining access to additional functions or confidential information.  For horizontal escalation, an attacker may be able to view or modify information associated with a different users account, potentially including financial information.

Recommendation and Resources
It is ISRs recommendation to use the corporate-wide authentication and authorization framework.  If this is not possible for some reason, use role-based access controls (RBACs) which look at the corporate LDAP user store for valid group membership.  Verify that the application is setup properly to limit normal user functionality to normal users and no more.  Verify that the application has proper session tracking in place to ensure users cannot view information or data related to other users.

https://www.owasp.org/index.php/Testing_for_Privilege_escalation_(OTG-AUTHZ-003)
https://en.wikipedia.org/wiki/Privilege_escalation

Forced Browsing
Description
Forced browsing is an attack where the aim is to enumerate and access resources that are not referenced by the application, but are still accessible.  By manipulating parameters that access files, an attacker can force the application to display other files that are stored on the server or an external source.  The use of ?../? will allow a hacker to navigate up through the directories and access files stored in other directories. 

Risk
The risk depends on what information can be found or is accessible through forced browsing.   If there are backup files or configuration files, these may contain sensitive information; if there are credentials or source code, this can be leverage for additional attacks; if there is access to the file system and internal network, this can be used to pivot further into the internal corporate network.

Recommendation and Resources
Verify that static file and directory enumeration is not possible based on access controls and that no backup configuration files or source code is present on the server.  Confirm that predictable resource location attacks are mitigated through alerting on spikes in 40x HTTP responses and if the requests are authenticated, account lockout occurs ? if unauthenticated, then a CAPTCHA or JavaScript challenge should be presented.

https://www.owasp.org/index.php/Forced_browsing
https://www.owasp.org/index.php/Path_Traversal
https://www.owasp.org/index.php/Path_Manipulation

Business Logic Misconfiguration
Description
Business logic misconfiguration is a broad vulnerability that encompasses how the application response compared to the intended or expected response.  Typically an attacker will enter information in to an application in order to illicit responses from the server that the developer never intended and then use this information to further compromise the system.

Risk
The risk depends on how the application responds

Recommendation and Resources
Verify the application has a default case switch for handling errors or input it does not understand.  Typically the application can return a custom 50x HTTP response page which indicates that there was a problem on the server-side, but does not tell the client any other information.  It is also important as part of the QA process to perform negative functionality testing ? that is testing how the application responds to unexpected input data.

Default Pages Accessible
Description
Upon installation many applications or services include a default page to inform the engineer that the application/service has been successfully installed.  However, if this page is not removed or the configuration is not changed such that the default information and pages are no longer accessible, then this is a vulnerability.

Risk
There are two primary risks associated with this vulnerability.  First, it discloses information about the system to an attacker which can lead to additional system compromise.  Second, if the default page itself has a vulnerability, this could be leveraged to further attack the system.  Additionally, having a default page still available speaks to the lack of quality assurance and security testing prior to releasing an application to production.

Recommendation and Resources
Remove all default pages or services.  Ensure that no sample pages, applications, services, or databases were also installed when the desired application was installed.
 
A8 ? CROSS-SITE REQUEST FORGERY
Cross-Site Request Forgery (CSRF)
Description
CSRF attack tricks the victim into sending a malicious request that inherits the identity and privileges of the victim to perform an undesired function on the victim's behalf. Basically, an attacker will use CSRF to trick a victim into accessing a website or clicking a URL link that contains malicious or unauthorized requests.

Risk
A successful CSRF exploit can compromise end user data or perform an operation on behalf of the user. If the targeted end user is the administrator account, this can compromise the entire web application.
Recommendation and Resources
Apply a synchronizer token pattern to remediate CSRF Vulnerability. The synchronizer token pattern requires the generation of random "challenge" tokens that are associated with the user's current session. Use established framework (like Spring Security) that include anti-CSRF tokens in its libraries.

Recommendation is to use CSRF protection for any request that could be processed by a browser by normal users. If you are only creating a service that is used by non-browser clients, you will likely want to disable CSRF protection.

https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)
http://www.acunetix.com/websitesecurity/csrf-attacks/
http://docs.spring.io/spring-security/site/docs/current/reference/html/csrf.html#csrf-include-csrf-token

Anti-CSRF Token Missing
Description
Cross-Site Request Forgery (CSRF) is an attack that forces an end user?s browser to execute unwanted, state-change actions on a web application in which they're currently authenticated.  Through the use of social engineering, an attacker tricks a user into executing actions in an application of the attacker?s choosing.  A valid CSRF token is applied to prevent CSRF which does not tell the server side application that the client has sent valid or trustable data, it rather confirms that it most likely was that specific user who intention to send the data.

Risk
CSRF attacks perform a transaction by an attacker under the guise of a legitimately authenticated user.  Therefore the risks associated with the CSRF attack depends on the level of authorization of the user.  As an example an attacker could use CSRF to add or change account information to benefit himself.

Recommendation and Resources
It is important to first ensure all XSS issues have been remediated because CSRF remediation can be circumvented using XSS.  After XSS mitigation, implement a non-predictable anti-CSRF token (also known as a Synchronizer Token Pattern) for any state changing operation ? for example add/delete/modify functions in the application.  The characteristics of the anti-CSRF token include:
?	Unique per user & per user session
?	Tied to a single user session
?	Large random value
?	Generated by a cryptographically secure random number generator

Ensure that you include the CSRF token in all PATCH, POST, PUT, and DELETE methods. One way to approach this is to use the _csrf request attribute to obtain the current CSRF Token

https://github.com/pillarjs/understanding-csrf
https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)_Prevention_Cheat_Sheet
http://www.cgisecurity.com/csrf-faq.html

 
A9 ? USING COMPONENTS WITH KNOWN VULNERABILITIES
Account Backdoor
Description
A backdoor is a malicious computer program that is used to provide the attacker with unauthorized remote access to a compromised system by exploiting security vulnerabilities. A backdoor works in the background and hides from the user. Programmers sometimes leave such backdoors in their software for diagnostics and troubleshooting purposes, however, hackers use them to surreptitiously break into or maintain access to the system.

Risk
An account backdoor is capable of stealing sensitive personal information, valuable documents, passwords, login names, identity details, logs user activity and tracking web browsing habits as well as recording keystrokes and capturing screenshots.  In addition, it may send all gathered data to a predefined e-mail address, upload it to a predetermined FTP server, or transfers it through a background Internet connection to a remote host. Infects files, corrupts installed applications and damages the entire system. It distributes infected files to remote computers with certain security vulnerabilities, performs attacks against hacker defined remote hosts.

Recommendation and Resources
Implement vulnerability scanners that detect vulnerabilities which potentially generate backdoor conditions, allowing IT admins to take actions and remove them. Antivirus software does not detect such vulnerabilities, but may detect backdoor payloads delivered when they?re being exploited.  It is recommended to use network and web vulnerability scanners along with antivirus software to detect most backdoors by identifying their signatures and by catching them in action when listening to open ports.

https://www.owasp.org/images/a/ae/OWASP_10_Most_Common_Backdoors.pdf
http://www.computereconomics.com/article.cfm?id=1112

Out of Date Software
Description
Part of the secure software lifecycle is ensuring that software stays up-to-date with the latest version and patches.  Typically software vendors issue patches or upgrades because of discovered vulnerabilities, therefore using out-of-date software increases the risk that a vulnerability will be exploited in the version that is being used. 

Risk
Out of date software can lead to full system compromise but is dependent on the type of vulnerabilities that are present in the old or unpatched software.

Recommendation and Resources
It is advised keep software up to date and apply all vendor released patches or upgrades.  If the vendor issues an end-of-life notice for software, it is recommended to replace that software with comparable software that will continue to be maintained.
http://www.windowsecurity.com/articles-tutorials/Cloud_computing/risk-running-obsolete-software-part4.html
https://www.owasp.org/index.php/Top_10_2013-A9-Using_Components_with_Known_Vulnerabilities

Using a Module/Function with a Known Vulnerability
Description
Sometimes applications are using modules or functions with known vulnerabilities.  Attacker identifies a weak component (module/function) through scanning or manual analysis. He customizes the exploit as needed and executes the attack. It gets more difficult if the used component is deep in the application.
Risk
If a vulnerable component is exploited, such an attack can facilitate serious data loss or server takeover. Applications using components with known vulnerabilities may undermine application defenses and enable a range of possible attacks and impacts. The risk is dependent both on the access the module/function has to the rest of the application and to the system as well as the information housed on the system.  It is best to assume full system compromise could occur.

Recommendation and Resources
Identify all components and the versions you are using, including all dependencies (e.g., plugins? versions).  Monitor the security of these components in public databases, project mailing lists, and security mailing lists, and keep them up to date.  Establish security policies governing component use, such as requiring certain software development practices, passing security tests, and acceptable licenses.  Where appropriate, consider adding security wrappers around components to disable unused functionality and/ or secure weak or vulnerable aspects of the component.

https://www.owasp.org/index.php/Top_10_2013-A9-Using_Components_with_Known_Vulnerabilities
 
A10 ? UNVALIDATED REDIRECTS AND FORWARDS
Unvalidated Redirects and Forwards
Description
Unvalidated redirects and forwards are possible when a web application accepts untrusted input that could cause the web application to redirect the request to a URL contained within untrusted input. By modifying untrusted URL input to a malicious site, an attacker may successfully launch a phishing scam and steal user credentials. Because the server name in the modified link is identical to the original site, phishing attempts may have a more trustworthy appearance. Unvalidated redirect and forward attacks can also be used to maliciously craft a URL that would pass the application?s access control check and then forward the attacker to privileged functions that they would normally not be able to access.

Risk
While there are other possible phishing scams, open redirectors create the possibility for people with malicious intent to gain the trust of a user who might click on the link. They can and have been used to trick users into revealing their passwords and downloading malware.
Recommendation and Resources
Safe use of redirects and forwards can be done in a number of ways:

?	Simply avoid using redirects and forwards.
?	If used, do not allow the url as user input for the destination. This can usually be done. In this case, you should have a method to validate URL.
?	If user input can?t be avoided, ensure that the supplied value is valid, appropriate for the application, and is authorized for the user.
?	It is recommended that any such destination input be mapped to a value, rather than the actual URL or portion of the URL, and that server side code translate this value to the target URL.
?	Sanitize input by creating a list of trusted URL's (lists of hosts or a regex).
?	Force all redirects to first go through a page notifying users that they are going off of your site, and have them click a link to confirm.

https://www.owasp.org/index.php/Unvalidated_Redirects_and_Forwards_Cheat_Sheet
https://www.credera.com/blog/technology-insights/java/top-10-web-security-risks-unvalidated-redirects-forwards-10/

Subresource Integrity (SRI) Missing
Description
Sub resource Integrity (SRI) is a security feature that enables browsers to verify that files they fetch (for example, from a CDN) are delivered without unexpected manipulation. It works by allowing you to provide a cryptographic hash that a fetched file must match.
It is an upcoming W3C standard that allows securing third-party loads of JavaScript and CSS. This is achieved by comparing the content with a cryptographic digest that is contained within the surrounding HTML tag. 
Risk
If an attacker gains control of a a Content Delivery Network (CDN), the attacker can inject arbitrary malicious content into files on the CDN (or replace the files completely) and thus can also potentially attack all sites that fetch files from that CDN.

Recommendation and Resources
Using a new specification called Sub resource Integrity, a website can include JavaScript that will stop working if it has been modified. Just by adding integrity attributes we can secure our third-party scripts & styles. This greatly diminishes security risks, as any change to those files will be detected and prevented by the browser.

An important side note is that for Sub resource Integrity to work, the CDN must support Cross-Origin Resource Sharing (CORS).

https://frederik-braun.com/using-subresource-integrity.html 
https://www.owasp.org/index.php/3rd_Party_Javascript_Management_Cheat_Sheet
https://www.w3.org/TR/SRI/

 
Appendix
Version History
Version	Author	Comment	Date

			
			
			


